# Домашняя работа №8

### 1. Сравнение dict, weakref и slots в [compariosn.py](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/comparison.py)
### 2. Провёл профилирование по [вызовам](https://github.com/Dadypool/deep_python_23b_Dadypool/tree/main/08#22-профилирование-по-вызовам) и [памяти](https://github.com/Dadypool/deep_python_23b_Dadypool/tree/main/08#21-профилирование-по-памяти)
### 3. Реализовал декоратор профилирования в [profile_deco.py](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/profile.py)
### 4. Прогнал через flake8, pylint и black


## Сравнение dict, weakref и slots
Создал класс объектов
Создал 3 типа: 
- класс с обычными атрибутами
- класс со слотами
- класс со слабыми ссылками

### 1. Сравнение по времени
Проверим время работы при создании 5*10**7 объектов с тремя атрибутами - объектами класса объектов и при чтении/записи атрибутов:

![Сравнение времени работы](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/time_comp.png)

Итоги:
Класс со слотами инициализируется быстрее всего. Слабые ссылки работают гораздо дольше, так как необходимо создать объект, а затем слабую ссылку на него.
Чтение работает чуть быстрее у слотов. Возможно, при большем числе атрибутов слоты будут ещё в большем отрыве от класса с обычными атрибутами. Объекты со слабыми ссылками хуже по скорости чтения/записи в два раза.

Выводы:
Если атрибуты класса чётко определены и важна скорость работы, желательно использовать __slots__. Слабые ссылки точно не для улучшения скорости работы.

### 2. Профилирование по вызовам и памяти
#### 2.1 Профилирование по памяти
Проведём профилирование по памяти для 10**6 объектов каждого класса
Расход памяти для класса с обычными атрибутами:
![Расход памяти для класса с обычными атрибутами](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/mem_class.png)
Затрачено примерно 390 MiB

Расход памяти для класса со слотами:
![Расход памяти для класса со слотами](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/mem_slots.png)
Затрачено примерно 340 MiB

Расход памяти для класса с атрибутами weakref:
![Расход памяти для класса с атрибутами weakre](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/mem_weakref.png)
Затрачено более 600 MiB

Выводы:
Объекты со слотами расходует на 13% меньше памяти в данном примере. Объекты со слабыми ссылками потребляют очень много памяти. Однако в данных примере в их объектах и создавались объекты класса MyObject, на которые создавились слабые ссылки. Weakref удобны при хранении ссылок на большие объекты, которые со временем будут ненужны, а слабые ссылки не будут мешать удалению этого объекта из памяти.


#### 2.2 Профилирование по вызовам:
![Профилирование по вызовам](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/call_stats.png)
Инициализация объектов каждого класса вызывалось 10 ** 6 раз.
Инициализация объектов, на которые ссылались объекты сравниваемых классов вызывалась 3*3 * 10 ** 6 раз