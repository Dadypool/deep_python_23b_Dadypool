# Домашняя работа №7

### 1. Сравнение dict, weakref и slots в [compariosn.py](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/comparison.py)
### 2. Результаты профилирования [profile.txt](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/profile.py)
### 3. Реализовал декоратор профилирования в [profile_deco.py](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/profile.py)
### 4. Прогнал через flake8, pylint и black


### Сравнение dict, weakref и slots
Создал класс объектов
Создал 3 типа: 
- класс с обычными атрибутами
- класс со слотами
- класс со слабыми ссылками

## 1.
Проверим время работы при создании 5*10**7 объектов с тремя атрибутами - объектами класса объектов и при чтении/записи атрибутов
Далее результат вывода из программы:

========================================
Compare time init for 10**7 objects:
        MyClass with __dict__: 17.31 seconds
        MyClass with __slots__: 16.21 seconds
        MyClass with weakref: 25.77 seconds
========================================
Compare time red/write for 10**7 objects:
        MyClass with __dict__: 0.91 seconds
        MyClass with __slots__: 0.90 seconds
        MyClass with weakref time red/write: 1.88 seconds
========================================

Итоги:
Класс со слотами инициализируется быстрее всего. Слабые ссылки работают гораздо дольше, так как необходимо создать объект, а затем слабую ссылку на него.
Чтение работает чуть быстрее у слотов. Возможно, при большем числе атрибутов слоты будут ещё в большем отрыве от класса с обычными атрибутами. Объекты со слабыми ссылками хуже по скорости чтения/записи в два раза.

Выводы:
Если атрибуты класса чётко определены и важна скорость работы, желательно использовать __slots__. Слабые ссылки точно не для улучшения скорости работы.

## 2.
Проведём профилирование по памяти для 10**6 объектов каждого класса
Расход памяти для класса с обычными атрибутами:
![Расход памяти для класса с обычными атрибутами](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/mem_class.png)
Затрачено примерно 390 MiB

Расход памяти для класса со слотами:
![Расход памяти для класса со слотами](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/mem_slots.png)
Затрачено примерно 340 MiB

Расход памяти для класса с атрибутами weakref:
![Расход памяти для класса с атрибутами weakre](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/mem_weakref.png)
Затрачено более 600 MiB

Выводы:
Объекты со слотами расходует на 13% меньше памяти в данном примере. Объекты со слабыми ссылками потребляют очень много памяти. Однако в данных примере в их объектах и создавались объекты класса MyObject, на которые создавились слабые ссылки. Weakref удобны при хранении ссылок на большие объекты, которые со временем будут ненужны, а слабые ссылки не будут мешать удалению этого объекта из памяти.


Профилирование по вызовам:
![Профилирование по вызовам](https://github.com/Dadypool/deep_python_23b_Dadypool/blob/main/08/src/call_stats.png)
Инициализация объектов каждого класса вызывалось 10**6 раз.
Инициализация объектов, на которые ссылались объекты сравниваемых классов вызывалась 3*3 * 10**6 раз